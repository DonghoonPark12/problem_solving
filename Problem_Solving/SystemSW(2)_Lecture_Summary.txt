■■ 시스템 소프트웨어 설계 part2 강의 정리 (1) ■■
※알고리즘 표현 방법
1. 자연어 표현
2. 순서도 작성
3. 의사코드 작성(Pseudo Code)
4. 프로그래밍 언어 작성

※ USB to 시리얼 IC란..
- 컴퓨터와 USB로 연결된 신호를 아두이노 내장 MCU를 위한 시리얼 신호로 변환시켜주는 IC.

※ 타겟보드 선정시 주의 깊게 봐야 할 3가지
1. 동작 전압
2. 아날로그 출력
3. EEPROM: 지워지지 않아야 될 값 저장을 위한 쓰기, 읽기 가능.

※ 배열: 동일 데이터 형을 가진 변수의 집합체
char myAddr[3] = {1, 2, 3};
char secArrt[3][2] = { {10,1}, {20,2}, {30,3} };

※'수치해석으로 해결한다' 함은 
- 일반적으로 수식적 해결보다 반복계산이라는 과정을 통해 문제해결에 가까이 가는 과정.
- 수치해석은 알고리즘이 많이 쓰이는 분야
- '배열'은 중간과정 저장이 용이, 반복연산에 유리하여 알고리즘 연산에 활용이 많음.

■■ 시스템 소프트웨어 설계 part2 강의 정리 (2) ■■
※ 알고리즘 검토
- 시간 복잡도: 수행시간(절대 수행시간X, 알고리즘 수행 연산의 개수에 의존).
- 공간 복잡도: 메모리 공간

※ 알고리즘 설계 접근 방식
1. 억지 접근 알고리즘 : 효율 보다는 동작에 우선 순위를 두는 알고리즘.
2. 탐욕 알고리즘 : 지역적으로 최선의 선택이 전체의 최선의 선택이 될 것이라는 가정하에 진행하는 알고리즘.
3. 분할정복 알고리즘(Divide and Conquer) : 주어진 문제를 보다 크기가 작은 부분 문제로 나누어 해결하는 방식.
4. 동적 프로그래밍 알고리즘 : 작은 문제를 풀고 그것을 바탕으로 큰 문제를 해결.
5. 확률적 알고리즘(Probabilistic Algm) 
6. 백트래킹 알고리즘 : 가능한 모든 경우에 대해 시도 한 후 그중에서 답을 찾는 알고리즘.
7. 최적분기 알고리즘  
-> 본 강의에선 센서 값 체크 후 저장 및 처리를 위해 배열 활용할 것.
-> 지속적 센서 체크 등과 관련된 알고리즘 사용할 것.

■■ 시스템 소프트웨어 설계 part2 강의 정리 (3) ■■
※ 인터럽트의 목적 : 응답성 향상, 예외 처리의 효율화, CPU 자원의 효율적 이용, 정확한 타이밍 제어 등등
		     
※ Background Process : 요구되는 작업을 수행하기 위해 특정 모듈이나 함수를 호출하는 무한 루프로 구성되어 있는 프로세스
			ex) Task 레벨 프로세스

※ Foreground Process : ISR과 같이 비동기적으로 발생하는 이벤트를 처리하는 프로세스
			ex) Interrupt 레벨 프로세스
			    - 배경 프로세스는 현재 작업을 멈추고 Foreground 프로세스를 수행

※ 인터럽트 소스 : 외부 - 페리페럴(GPIO, ADC 등) , 내부 - 타이머, 통신 등

※ 인터럽트 벡터 : 인터럽트 발생 시 서비스 루틴을 위해 참조해야 하는 포인터 (ISR 을 가리키는 포인터 인듯)

※ 인터럽트 우선순위 : 복수 개의 인터럽트 발생 시 우선순위 결정 체계

※ ISR : 인터럽트 벡터에 의해 포인트 되어져(Pointed) 존재하는   수행되어야 할 프로그램(특정 주소에 위치)
      
※ 비 동기적으로 인터럽트가 발생, 현재 실행 중인 프로그램 강제 중단 -> MCU의 인터럽트 대기 레지스터에 발생된 이벤트 세팅(우선순위 체계에 의해 결정된 인터럽트)
   -> CPU는 우선순위에 따라 인터럽트 벡터 발생 시킴 -> 인터럽트 벡터는 ISR 위치 정보를 바탕으로 ISR을 수행
   -> 작업이 끝나면 다시 진행중이던 Background 프로그램으로 돌아가 멈춘 곳 다음부터 실행.


■■ 시스템 소프트웨어 설계 part2 강의 정리 (4) ■■
- 타이머/ 카운터를 이해하고 활용可
- 시분할 알고리즘을 이해하고 활용可
- 타이머 인터럽트를 이용한 시분할 방식을 설계할 수 있다.

※ 타이머: (동기모드) 1) 일정한 갯수의 클럭 주기를 묶어 하나의 시간 단위로 가지거나 파형을 만든다. 
	   2) 시간 단위 뒤에 인터럽트를 발생 시켜 특정 동작을 행한다. ex) Overflow interrupt
           ex) 전자시계는 내부의 타이머를 이용.
	   내부 클럭사용 -> 타이머

※ 카운터: (비동기) 외부에서 들어오는 일정 갯수 만큼의 클럭을 측정하여 시간이나 이벤트를 카운팅함 
	   외부 클럭사용 -> 카운터
	   cf) 프리스케일러를 이용하면 16bit 카운터 단독으로 사용할 때 보다 카운팅 범위 넓어진다.

※ 8bit 타이머 - 입력 클럭 1Mhz(1초에 1024k수 진동) 타이머 주기 = 약 1마이크로s.
 		 카운트 갯수는 256개 이므로 256마이크로s 시간을 단위로 가질 수 있다.


※ 8bit 타이머 + (10bit)프리스케일러 - 10bit 즉 1024마이크로s 마다 카운터 동작 시킨다.
				       결국 1024마이크로s * 256마이크로s = 262.144ms 까지 범위가 확장 된다.

※ 시분할 동작: 페리페럴을 시간적으로 동시에 수행하는 것 처럼 동작 시키는 것.

※ 테스크 기반 방식 : 테스크(CPU를 독점하고 있다고 생각하고 수행하는 프로그램 단위)들을 OS가 적당한 시간 단위로 교체하여 수행한다면, 외부에선
		      동시에 수행하는 것처럼 보인다(테스크 기반의 시분할 방식).

EX) 아두이노에서 시분할 처리 시나리오: 
1. 아두이노 타이머에서 시분할을 위한 기준 동기 시간 생성
2. 타이머 인터럽트에 의한 타이머 틱 발생 (http://www.instructables.com/id/Arduino-Timer-Interrupts/?ALLSTEPS )
3. 타이머 틱 발생 시 복수의 작업내용 순차적으로 실행







